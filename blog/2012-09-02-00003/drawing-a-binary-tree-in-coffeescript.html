<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="description" content="HectorCorrea.com">
    <meta name="author" content="hector@hectorcorrea.com">

    <title>HectorCorrea.com</title>

    <link rel="shortcut icon" href="/public/favicon.ico" />
    <link rel="apple-touch-icon" href="/public/favicon.png"/>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link rel="me" href="https://mastodon.social/@hectorjcorrea" />
    <link rel="canonical" href="https://hectorcorrea.com" />
 
    <style>
      .header-container {
        background-color:  #e1ebf7;
        margin-left: 0px;
        max-width: unset;
        border-bottom-style: solid;
        border-bottom-width: 2px;
        max-height: 75px;
      }

      h1 {
        margin-top: 20px;
      }

      blockquote {
        padding: 10px 20px;
        margin: 0 0 20px;
        border-left: 5px solid #eee;
        font-family: Courier New,Courier,Lucida Sans Typewriter,Lucida Typewriter,monospace;
      }

      img {
        padding: 5px;
        box-shadow: 3px 3px 8px #222;
        margin-right: 10px;
        margin-bottom: 10px;
      }

      /* Overwrite Bootstrap's default */
      code {
        background-color: #f0f1f2;
        color: #0D0D0D; /* gray-ish */
      }

      /* Custom code and terminal styles */
      pre, pre.code {
        margin-left: 20px;
        display: block;
        padding: 9.5px;
        margin: 0 0 10px;
        margin-left: 0px;
        font-size: 13px;
        line-height: 1.428571429;
        color: #333;
        word-break: break-all;
        word-wrap: break-word;
        background-color: #f5f5f5;
        border: 1px solid #ccc;
        border-radius: 4px;
      }

      pre.terminal {
        margin-left: 20px;
        margin-bottom: 20px;
        background-color: #363446;
        color: #DAD681; /* yellow-ish */
        padding-bottom: 10px;
        padding-top: 10px;
        padding-left: 10px;
        padding-right: 50px;
      }

      .socialList {
        list-style: none;
        padding: 5px;
      }
      
      .socialLogo {
        padding: 0px;
        box-shadow: none;
        margin-right: 0px;
        margin-bottom: 0px;
        width: 16px;
      }

      footer {
        font-weight: lighter;
      }
    </style>
  </head>
  <body>

    <div class="container header-container">
      <!-- header source: https://getbootstrap.com/docs/5.1/examples/headers/
        changes: removed border-bottom -->
      <header class="d-flex flex-wrap justify-content-center py-3 mb-4">
        <a href="/" class="d-flex align-items-center mb-3 mb-md-0 me-md-auto text-dark text-decoration-none">
          <span class="fs-4">HectorCorrea.com</span>
        </a>
        <ul class="nav nav-pills">
          <li class="nav-item"><a id="home-menu" href="/" class="nav-link" aria-current="page">Home</a></li>
          <li class="nav-item"><a id="about-menu" href="/about" class="nav-link">About</a></li>
          <li class="nav-item"><a id="blog-menu" href="/blog" class="nav-link">Blog</a></li>
        </ul>
      </header>
    </div>

    <div class="container">
      <h1>Drawing a Binary Tree in CoffeeScript</h1>

<p><img src="https://hectorcorrea.com/images/binarytreecoffee.png" alt="Binary Tree" title="Binary Tree" /></p>

<p>A few months ago I wrote a small <b>CoffeeScript program to draw binary search trees on a web page page</b> using the HTML 5 Canvas element and was very pleased with clarity and structure of the resulting code. This blog post elaborates on the code structure and how it compares to previous implementations of the same idea that I have done in other languages.</p>

<p>I’ve written programs to draw binary search trees before in C# and Ruby and I wasn’t sure how a CoffeeScript implementation would compare against implementations in more traditional object oriented programming languages. Thanks to CoffeeScript’s support for classes the structure of this implementation is pretty much as you would expect: a BinaryNode class to hold node data, a BinaryTree class to implement the basic binary search tree operations (add, walk), and a BinaryTreeDrawer to calculate the coordinates where each of the nodes should be drawn.</p>

<p>In addition, since this project requires only client-side code (I don’t store the binary search tree data in a server database) it’s was very pleasant not having to deal with a context switching between a “client side” mental model and a “server side” one. This is uncommon in real life projects but it was a nice bonus for a pet project like this.</p>

<p>You can see a <b>running version</b> of this project <a href="https://hectorcorrea.com/demos/binary-tree-coffee/index.html">here</a>. The full CoffeeScript (and JavaScript) <b>source code</b> is available on <a href="https://github.com/hectorcorrea/binary-tree-coffee">github</a>.</p>


<h2>Binary Tree or Binary Search Tree</h2>

<p>Properly speaking the code in this blog post implements a Binary Search Tree (BST) which is a more specific version of a Binary Tree. Cormen et al. give a good explanation of this on their book <a href="http://www.amazon.com/Introduction-Algorithms-Second-Thomas-Cormen/dp/0262032937">Introduction to Algorithms</a>. Binary trees are trees in which each node has at most two children, one of them called "left subtree" and the other called "right subtree" but there is no order enforced per-se (pp. 1178). Binary Search Trees on the other hand are always stored in a way as to satisfy the binary-search-tree property (pp. 287):</p>

<blockquote>
Let x be a node in a binary search tree.<br/>
If y is a node in the left subtree of x, then y.key ? x.key.<br/>
If y is a node in the right subtree of x, then y.key ? x.key.<br/>
</blockquote>

<p>I took a bit of a liberty on this blog post (and its related source code) and use both terms interchangeably. Please be aware that all of the references to <i>binary tree</i> in this blog post are in fact references to <i>binary search trees</i>.</p>


<h2>Basic Structure of the Code</h2>

<p>The main classes that I used to implement the binary search tree drawer functionality are BinaryNode, a BinaryTree, and a BinaryTreeDrawer.</p>

<p>The <b>BinaryNode</b> class is just a small “data class” that stores the information about each node, namely the value of the node and pointers to the node to the left and right of it (<a href="https://gist.github.com/hectorcorrea/2772787">gist</a>).</p>

<pre class="code">
class BinaryNode
  constructor: (@value) -&gt; 
    @left = null
    @right = null

root = exports ? window
root.BinaryNode = BinaryNode
</pre>

<p>The <b>BinaryTree</b> class implements the functionality to add nodes to the tree and walk the tree. The <i>add</i> method takes care of adding each new value to the tree and updating the other nodes accordingly. The <i>walk</i> method goes through each node of the tree in-order and calls another function to allow you to decide what to do on each node (e.g. print it to the screen.)</p>

<p>The code for this class is shown below. Notice that this is just a partial implementation of a binary search tree since it only implements the add and walk methods but is missing functionality to remove nodes, search for values, find the min and max values in the tree, et cetera.</p>

<pre class="code">
{BinaryNode} = require?("./binary_node") or window

class BinaryTree

  constructor: (rootValue) -&gt;
    @root = new BinaryNode rootValue
    @count = 1


  add: (value) -&gt;
    newNode = new BinaryNode value
    node = @root
    loop
      if value &gt;= node.value
        if node.right is null
          node.right = newNode
          break
        else
          node = node.right
      else
        if node.left is null
          node.left = newNode
          break
        else
          node = node.left

    @count++ 


  walk: (callback) -&gt;
    @walkFromNode(callback, @root)


  walkFromNode: (callback, node) -&gt;
    @walkFromNode(callback, node.left) unless node.left is null
    callback(node)
    @walkFromNode(callback, node.right) unless node.right is null


  toString: -&gt;
    values = []
    @walk (node) -&gt; values.push node.value
    values.join(', ')

root = exports ? window
root.BinaryTree = BinaryTree
</pre>

<p>The <b>BinaryTreeDrawer</b> class walks through the nodes of the tree and calculates the coordinates where each of them should be drawn. This class does not draws the tree per-se, rather it calls a function of your choosing with the coordinates where the node should be drawn.</p>

<pre class="code">
{BinaryTree} = require?("./binary_tree") or window

class BinaryTreeDrawer

  constructor: (@tree, @distanceX=20, @distanceY=20) -&gt;


  # Draws a binary tree (always starts at the root)
  draw: (x, y, callback) -&gt;
    @drawNode @tree.root, x, y, callback


  # Draws a binary tree starting at the specified node
  drawNode: (node, x, y, callback) -&gt;
    return if node is null
    callback node.value, x, y, x, y
    @drawLeft node.left, x, y, callback unless node.left is null
    @drawRight node.right, x, y, callback unless node.right is null


  drawLeft: (node, parentX, parentY, callback) -&gt;
    if node.right is null
      count = 0
    else
      count = 1 + @childrenCount node.right

    x = parentX - @distanceX - (count * @distanceX)
    y = parentY + @distanceY
    callback(node.value, x, y, parentX, parentY)

    @drawLeft node.left, x, y, callback unless node.left is null
    @drawRight node.right, x, y, callback unless node.right is null


  drawRight: (node, parentX, parentY, callback) -&gt;
    if node.left is null
      count = 0
    else
      count = 1 + @childrenCount node.left

    x = parentX + @distanceX + (count * @distanceX)
    y = parentY + @distanceY
    callback node.value, x, y, parentX, parentY

    @drawLeft node.left, x, y, callback unless node.left is null
    @drawRight node.right, x, y, callback unless node.right is null


  childrenCount: (node) -&gt;
    count = 0
    count += 1 + @childrenCount node.left unless node.left is null
    count += 1 + @childrenCount node.right unless node.right is null
    count


root = exports ? window
root.BinaryTreeDrawer = BinaryTreeDrawer
</pre>

<h2>Console Application</h2>

<p>File binary_console.coffee shows a very sample of usage of the BinaryTree and BinaryTreeDrawer classes. This console application creates a binary search tree, adds a few nodes to it, and outputs to the console the coordinates where each of these nodes should be drawn.</p>

<pre class="code">
# Node.js console demo program for the BinaryTree and BinaryTreeDrawer
{BinaryTree} = require('./binary_tree')
{BinaryTreeDrawer} = require('./binary_tree_drawer')

# Create a binary tree
tree = new BinaryTree(100)
tree.add 20
tree.add 50
tree.add 200
tree.add 133
tree.add 250
console.log "Values = #{tree.toString()}"

# "Draw" the tree (i.e. output each nodes' coordinates to the console)
console.log "Coordinates"
drawer = new BinaryTreeDrawer(tree)
drawer.draw 100, 100, (v, x1, y1, x2, y2) -&gt; 
  console.log "#{v} (#{x1}, #{y1}) / (#{x2}, #{y2})" 
</pre>

<p>If you have CoffeeScript installed on your box you can just run “coffee binary_console” and you’ll see an output similar to this:</p>

<p><img src="https://hectorcorrea.com/images/binarytreeconsole.png" alt="Console output" title="Console output" /></p>


<h2>The Demo Web Page</h2>

<p>Once I implemented the BinaryTreeDrawer it was easy to hook this to a web page and actually draw a binary search tree using the HTML 5 Canvas element. The callback passed to the drawer code in this case actually draws circles and lines for each node rather than just outputting the result to the console. Below is a snippet of the code found in binary_web.coffee that shows the basic code to draw the tree:</p>

<pre class="code">
drawNode = (v, x1, y1, x2, y2) -&gt;

  rootNodeColor = "#4CC552" # green
  lastNodeColor = "#ADDFFF" # blue
  nodeColor = "#FDD017"     # yellow

  color = nodeColor
  color = rootNodeColor if x1 is x2 and y1 is y2
  color = lastNodeColor if v is lastValueAdded

  drawLine x1, y1, x2, y2
  drawCircle x1, y1, nodeSize, color
  drawLabel x1, y1, v


$ -&gt;
  # initialize the binary tree with some data..
  tree = new BinaryTree 100
  tree.add 1000
  tree.add 50
  tree.add 150
  tree.add 75
  tree.add 200
  tree.add 24
  tree.add 8

  offsetX = 30
  offsetY = 30
  drawer = new BinaryTreeDrawer tree, offsetX, offsetY

  startX = canvasWidth / 2
  startY = 30
  drawer.draw startX, startY, drawNode
</pre>


<h2>Final Thoughts</h2>

<p>As I said at the beginning of this blog post, I was very pleased with how succinct the code in CoffeeScript to implement a binary search tree drawer ended. The clear and concise CoffeeScript syntax aided with CoffeeScript support for a traditional way of defining classes (while behind the scenes using JavaScript prototypes) resulted in code that is both easy to write, test, and maintain.</p>


<h2>Related posts</h2>

<ul>
<li>A review of <a href="https://hectorcorrea.com/blog/learning-javascript-data-structures-and-algorithms/58">Learning JavaScript Data Structures and Algorithms</a> (2015)
<li><a href="https://hectorcorrea.com/blog/drawing-a-binary-tree-in-ruby/13">Drawing a Binary Tree in Ruby</a> (2011)
<li><a href="https://hectorcorrea.com/blog/binary-tree-in-c-sharp/21">Binary Tree in C#</a> (2006)
</ul>


    </div>

    <div class="container">
      <footer>
        <p>
          <hr>
          License <a rel="license" target="_blank" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>
        </p>
      </footer>
    </div>

    <script type="text/javascript">
      // Redirect legacy blog URLs
      if (window.location.hash.startsWith("#/blog")) {
        window.location = window.location.toString().replace("#/blog/","blog/");
      }

      // Highlight the current menu option
      var highlightMenu = function() {
        var menuId = "home-menu";
        var url = window.location.pathname;
        if (url.startsWith("/blog/")) {
          menuId = "blog-menu";
        } else if(url == "/about") {
          menuId = "about-menu";
        } if(url == "/draft") {
          menuId = "draft-menu";
        }if(url == "/page") {
          menuId = "page-menu";
        }
        var el = document.getElementById(menuId);
        el.classList.add("active");
      }

      // Display the session expiration time in local time
      var displaySessionLocalTime = function() {
        var el = document.getElementById("sessionExpiresOn");
        if (el === null) {
          return;
        }
        var zTime = el.textContent.substring(0,19) + "Z";
        var date = new Date(zTime);
        el.textContent = date.toLocaleString();
      }

      highlightMenu();
      displaySessionLocalTime();
    </script>
  </body>
</html>
