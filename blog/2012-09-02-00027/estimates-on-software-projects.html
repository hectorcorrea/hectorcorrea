<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="description" content="HectorCorrea.com">
    <meta name="author" content="hector@hectorcorrea.com">

    <title>HectorCorrea.com</title>

    <link rel="shortcut icon" href="/public/favicon.ico" />
    <link rel="apple-touch-icon" href="/public/favicon.png"/>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link rel="me" href="https://mastodon.social/@hectorjcorrea" />
    <link rel="canonical" href="https://hectorcorrea.com" />
 
    <style>
      .header-container {
        background-color:  #e1ebf7;
        margin-left: 0px;
        max-width: unset;
        border-bottom-style: solid;
        border-bottom-width: 2px;
        max-height: 75px;
      }

      h1 {
        margin-top: 20px;
      }

      blockquote {
        padding: 10px 20px;
        margin: 0 0 20px;
        border-left: 5px solid #eee;
        font-family: Courier New,Courier,Lucida Sans Typewriter,Lucida Typewriter,monospace;
      }

      img {
        padding: 5px;
        box-shadow: 3px 3px 8px #222;
        margin-right: 10px;
        margin-bottom: 10px;
      }

      /* Overwrite Bootstrap's default */
      code {
        background-color: #f0f1f2;
        color: #0D0D0D; /* gray-ish */
      }

      /* Custom code and terminal styles */
      pre, pre.code {
        margin-left: 20px;
        display: block;
        padding: 9.5px;
        margin: 0 0 10px;
        margin-left: 0px;
        font-size: 13px;
        line-height: 1.428571429;
        color: #333;
        word-break: break-all;
        word-wrap: break-word;
        background-color: #f5f5f5;
        border: 1px solid #ccc;
        border-radius: 4px;
      }

      pre.terminal {
        margin-left: 20px;
        margin-bottom: 20px;
        background-color: #363446;
        color: #DAD681; /* yellow-ish */
        padding-bottom: 10px;
        padding-top: 10px;
        padding-left: 10px;
        padding-right: 50px;
      }

      .socialList {
        list-style: none;
        padding: 5px;
      }
      
      .socialLogo {
        padding: 0px;
        box-shadow: none;
        margin-right: 0px;
        margin-bottom: 0px;
        width: 16px;
      }

      footer {
        font-weight: lighter;
      }
    </style>
  </head>
  <body>

    <div class="container header-container">
      <!-- header source: https://getbootstrap.com/docs/5.1/examples/headers/
        changes: removed border-bottom -->
      <header class="d-flex flex-wrap justify-content-center py-3 mb-4">
        <a href="/" class="d-flex align-items-center mb-3 mb-md-0 me-md-auto text-dark text-decoration-none">
          <span class="fs-4">HectorCorrea.com</span>
        </a>
        <ul class="nav nav-pills">
          <li class="nav-item"><a id="home-menu" href="/" class="nav-link" aria-current="page">Home</a></li>
          <li class="nav-item"><a id="about-menu" href="/about" class="nav-link">About</a></li>
          <li class="nav-item"><a id="blog-menu" href="/blog" class="nav-link">Blog</a></li>
        </ul>
      </header>
    </div>

    <div class="container">
      <h1>Estimates on Software Projects</h1>
<p>Estimates is one of the most controversial topics on software development, including the process to calculate them and the value that they add to the software development process.</p>

<p>Every team that I have worked with needs to provide estimates on how long it's going to take to complete a specific feature of a system. Yet, most teams seem to struggle with this activity. Developers enjoy attending a meeting to provide estimates as much as they enjoy visiting the dentist. Project owners typically complain how unreliable estimates on software projects are, to them is unbelievable that even that developers have been writing software for many years cannot give accurate estimates.</p>

<p>In my experience there are several reasons why providing estimates is so hard:</p>

<ul>
<li>Poor specifications/Lack of domain knowledge
<li>Technology challenges
<li>Developers are optimistic
<li>Software development is tough
</ul>


<h2>Poor specifications</h2>

<p>Poor specifications is the most commonly voiced reason for inaccurate estimates. And for a good reason. It is typical for developers to be asked to estimate features that they don't fully understand. The client requests a new screen to do X but there is a lot of unwritten expectations for this new feature that users will demand once they start using it but that developers don't know about. This is usually due to lack of business domain knowledge. Developers are trained on software development and very little (or nothing) in the specific business domain. If the software that is being written is for insurance billing is very unlikely that the developers will have enough education and training on insurance and/or accounting. They might have been working many years in software development but this might be the first time they are faced with a screen for insurance billing purposes.</p>

<p>Even when a decent amount of conversation between developers, business analysts, and product owners take place to explore what the requested feature will entail, there is inevitable a lot of things that are left unsaid that will be find out when the feature is developed and presented to the user. I've worked on companies where we received reams of paper with specifications that looked like they covered every possible detail about the feature to be built just to find out that (1) they are still incomplete or (2) they don't really represent what the customer wants. I've produced my fair share of specs that I thought were enough to provide accurate estimates just to find out that nope, there is still a lot left unsaid that will not be discovered until the software is written and presented to the users for feedback.</p>


<h2>Technology challenges</h2>

<p>Most software development groups try to stay up to date on technology and upgrade to new versions of compilers, databases, development environments, and such. This is usually a good thing since these new tools are meant to speed up the development process and make better use of existing hardware. But there is a cost associated with these upgrades. Developers need to spend time performing upgrades, learning new tools and ways of doing things, and this might not be cheap. Plus this happens on a regular basis. For example, since 2000 Microsoft has released three versions of C# (C# in 2000, C# 2.0 in 2005, and C# 3.0 in 2007) during the same time Microsoft has released three versions of SQL Server (SQL 2000, SQL 2005, and SQL 2008.)</p>

<p>You may be tempted to say 'the heck with it, we are not going to update anymore' but there is also a cost associated with this. For once, your system might not run on new computers or just look ugly (e.g. imagine a DOS application running on Windows.) Secondly, developers tend to be technology driven and you may lose some of your best developers if they see that they are falling behind in technology and their skills are not up to date.</p>


<h2>Developers are optimistic</h2>

<p>Most developers that I've met (myself included) are optimistic by nature. We are optimistic people and we like to please our customers. This has an impact on the estimates that we provide. We tend to provide estimates for the best case scenario even when experience tells us that the best case scenario hardly ever materializes in software development. Even when we try to account for the unexpected we do it in an optimistic way. Or as Brooks will say in the Mythical Man-Month [p. 15] "the assumption that all will go well has a probabilistic effect on the schedule."</p>


<h2>Software development is tough</h2>

<p>Software development is a tough activity. It requires dealing with abstractions, a lot of unknowns, on a tight schedule, and with new tools and technologies. Most activities in a business environments deal with physical limitations like size, weight, cost, counts, and other well understood constrains. Software on the other hand deals with "almost pure thought-stuff" [Brooks, p. 7] Estimates on an unconstrained environment like this are not trivial.</p>


<h2>Do we need estimates?</h2>

<p>Yes, we definitively do. Despite the grim picture that I might have painted so far, I strongly believe that estimates are valuable in software projects. Estimates are like price tags in the sense that they allow product owners make better decisions when it comes to deciding priorities for a software project. If there are four new features being requested by the users and three of them will take one week each but the fourth one looks like it is going to take two months alone, the product owner will be better able to decide what is best for the product. She might decide to complete the three one-week features and delay the large one for a better time, or vice-versa. But she will be able to make this decision having an idea on the size of the features.</p>

<p>In my experience there are two things that you can do to get the most out of estimates for software projects <i>even when</i> they are not accurate.</p>

<p>One is to divide and conquer. Estimate small blocks of functionality so that even if estimates are not accurate they are not off by a lot either. If a task is estimated to take 2 days and it takes twice as much you can deal with it 2 days later and adjust your planning. However, if a task is estimated to take 2 months and it takes twice as much, four months later is probably too late to address the problem. Even more, if developers in a team can blow a 2 days estimated (for whatever reasons) imagine the likelihood of blowing a 2 months estimate.</p>

<p>The second thing that we can do is to constantly calibrate project expectations. To put it bluntly be realistic and use history as a guidance on how long stuff takes to be completed rather than be guided by hope. It is very common for people to say &quot;this time it took me 2 weeks to complete X but with what I know now it would take me only 1 week next time.&quot; This hardly ever works out. For once, remember that developers are optimistic. We are bound to take this posture. If it took 2 weeks to do something there is probably a very good reason for it. You should use that number as your baseline in the future and only reduce the estimate once you have proven than it can be done in half as much. Koskela and Howell have a great <a href="http://www.leanconstruction.org/pdf/ObsoleteTheory.pdf">paper</a> in which they propose moving away from the thermostat model (in which an arbitrary productivity goal is set at the onset) into a scientific experimentation model in which we adjust based on previous results.</p>


<h2>How to calculate estimates?</h2>

<p>Since estimates are approximations, not promises, I prefer a light weight approach to calculate them rather than spending a whole lot of time on them. By light weight I mean the team getting together for no more than 3 hours to estimate what we think will be able to accomplish in the next two weeks. In my experience teams can come up with "good enough" estimates in relatively short term. David Anderson has a tongue-in-cheek post where he calls for people to <a href="http://www.agilemanagement.net/Articles/Weblog/StopEstimating.html">stop estimating</a>. In reality he calls for <a href="http://www.agilemanagement.net/Articles/Weblog/AgileEstimating.html">agile estimating</a> rather than no estimates at all. In agile methods not a lot of time is spent calculating something that we cannot guarantee. It's better to spend that time producing software and delivering features to the user rather than promises.</p>

<p>Mike Cohn's book on <a href="http://www.amazon.com/Agile-Estimating-Planning/dp/0131479415">Agile Estimating and Planning</a> is a very good book on the subject. He does a great way of describing the use of story points and velocity to do long term planning on projects. Highly recommended if you are doing agile software development.</p>

<p>Joel Spolsky has an article on <a href="http://www.stickyminds.com/BetterSoftware/magazine.asp?fn=cifea&amp;id=94">Evidence-Based Scheduling</a> (EBS) in which he uses a Monte Carlo simulation to calculate the likelihood that a particular estimate will be met. Spolsky's approach sounds interesting but I have not tried it myself. The fact that uses historic values to calculate probabilities sounds promising. Still, I am afraid that it requires more time and effort than the value that it provides but I don't have any experience with it.</p>


<h2>What to do about missed estimates?</h2>

<p>Of the things that are controversial about estimates the one about missed estimates is probably the worst. It's almost taboo. Although everybody misses estimates but nobody wants to talk about it.</p>

<p>If you (or your team) misses an estimate, get over it. It happens. Don't let it bring you down. Review why you missed it and act on your findings. Perhaps the task is just more complicated than you thought -- it is perfectly OK to admit this. Maybe you need to break the task down in smaller chunks next time, or you need less distractions. What ever you do however, make sure to use the knowledge that it took longer than you expected next time you estimate a similar task. Don't tell yourself that &quot;next time will be better because I've been there before.&quot; Remember: use history as a guidance rather than hope.</p>

<p>If somebody else misses an estimate see the previous paragraph. Talk with them to see why it was missed and act on it. Don't expect that because somebody thought something would take 5 days that is the time it will take. Remember that it is an estimate, a forecast.</p>

<p>There might be instances where a team or an individual developer <i>constantly misses estimates by a long shot</i>. If that is the case, there are perhaps larger issues that need to be addressed. Does the team/developer has the right tools for the job? Is the team/developer qualified for the job? Are the expectations for the team/developer realistic? Is it always the same team/individual? These are perfectly valid questions on a team/individual that is not performing at the pace that the business expects. The problem might be the team, the expectations, or both.</p>


<h2>The role of the product owner</h2>

<p>In my experience most product owners learn the effectiveness of their team's estimates in a few cycles. Product owners are not necessarily as optimistic as developers and they can provide valuable feedback to the team after just a few rounds of estimates. This is great feedback that a lot of teams don't use. Product owners bring different experiences, business knowledge, and personality styles to the team that can be very useful when estimating and setting expectations.</p>

    </div>

    <div class="container">
      <footer>
        <p>
          <hr>
          License <a rel="license" target="_blank" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>
        </p>
      </footer>
    </div>

    <script type="text/javascript">
      // Redirect legacy blog URLs
      if (window.location.hash.startsWith("#/blog")) {
        window.location = window.location.toString().replace("#/blog/","blog/");
      }

      // Highlight the current menu option
      var highlightMenu = function() {
        var menuId = "home-menu";
        var url = window.location.pathname;
        if (url.startsWith("/blog/")) {
          menuId = "blog-menu";
        } else if(url == "/about") {
          menuId = "about-menu";
        } if(url == "/draft") {
          menuId = "draft-menu";
        }if(url == "/page") {
          menuId = "page-menu";
        }
        var el = document.getElementById(menuId);
        el.classList.add("active");
      }

      // Display the session expiration time in local time
      var displaySessionLocalTime = function() {
        var el = document.getElementById("sessionExpiresOn");
        if (el === null) {
          return;
        }
        var zTime = el.textContent.substring(0,19) + "Z";
        var date = new Date(zTime);
        el.textContent = date.toLocaleString();
      }

      highlightMenu();
      displaySessionLocalTime();
    </script>
  </body>
</html>
